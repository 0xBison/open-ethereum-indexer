# Working with Entities

The Open Ethereum Indexer leverages [TypeORM](https://github.com/typeorm/typeorm) for database operations, simplifying the process of defining, storing, and querying blockchain data. It is essential to execute ALL SQL queries using TypeORM. This approach ensures that blocks are handled as a single database transaction, ensuring that if any part of the transaction fails, the entire transaction fails, thereby maintaining data integrity. Additionally, it enables the indexer to track changes that need to be reversed in the event of a blockchain reorganization.

## Creating Entities

Entities are TypeScript classes that map to database tables. Here's how to create an entity for storing ERC-20 transfers:

```typescript
// entities/Transfer.entity.ts
import { Entity, Column, PrimaryGeneratedColumn, Index } from 'typeorm';

@Entity()
export class Transfer {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  @Index()
  contractAddress: string;

  @Column()
  @Index()
  from: string;

  @Column()
  @Index()
  to: string;

  @Column('varchar')
  value: string;

  @Column('int')
  @Index()
  blockNumber: number;

  @Column()
  transactionHash: string;

  @Column('int')
  logIndex: number;

  @Column('int')
  timestamp: number;
}
```

### Important TypeORM Decorators

- `@Entity()` - Marks a class as a database entity
- `@Column()` - Defines a column in the table
- `@PrimaryGeneratedColumn()` - Creates an auto-incrementing primary key
- `@Index()` - Creates a database index for faster queries

## Mapping Solidity Types to TypeORM

Ethereum data types often need special handling when stored in a database:

| Solidity Type | TypeORM Type | Notes                                   |
| ------------- | ------------ | --------------------------------------- |
| `address`     | `string`     | Store as hex string                     |
| `uint256`     | `string`     | Store as string to avoid precision loss |
| `bytes32`     | `string`     | Store as hex string                     |
| `bool`        | `boolean`    | Direct mapping                          |
| `string`      | `string`     | Direct mapping                          |
| `array`       | `string`     | Store as JSON string                    |

### Handling Big Numbers

For large numbers (like token amounts), use string representation:

```typescript
@Column('varchar')
value: string; // Stores uint256 as string to preserve precision
```

## Using Entities in Handlers

Here's how to use your entities in event handlers:

```typescript
import { onEvent } from '@open-ethereum/indexer';
import { getRepository } from 'typeorm';
import { Transfer } from './entities/Transfer.entity';

onEvent('*:Transfer', {
  onIndex: async (payload) => {
    const { log, parsedEvent, block } = payload;
    const { from, to, value } = parsedEvent.args;

    const transferRepo = getRepository(Transfer);

    const transfer = new Transfer();
    transfer.contractAddress = log.address;
    transfer.from = from;
    transfer.to = to;
    transfer.value = value.toString();
    transfer.blockNumber = block.number;
    transfer.transactionHash = log.transactionHash;
    transfer.logIndex = log.logIndex;
    transfer.timestamp = block.timestamp;

    await transferRepo.save(transfer);
  },
});
```

## Querying Entities

You can query your entities using TypeORM's repository pattern:

```typescript
import { getRepository } from 'typeorm';
import { Transfer } from './entities/Transfer.entity';

async function getTransfersForAddress(address: string, limit: number = 10) {
  const transferRepo = getRepository(Transfer);

  const transfers = await transferRepo.find({
    where: [{ from: address }, { to: address }],
    order: {
      blockNumber: 'DESC',
      logIndex: 'DESC',
    },
    take: limit,
  });

  return transfers;
}
```

## Entity Relations

You can also define relationships between entities:

```typescript
// entities/Token.entity.ts
import { Entity, Column, PrimaryColumn, OneToMany } from 'typeorm';
import { Transfer } from './Transfer.entity';

@Entity()
export class Token {
  @PrimaryColumn()
  address: string;

  @Column()
  name: string;

  @Column()
  symbol: string;

  @Column('int')
  decimals: number;

  @OneToMany(() => Transfer, (transfer) => transfer.token)
  transfers: Transfer[];
}

// entities/Transfer.entity.ts (updated)
import {
  Entity,
  Column,
  PrimaryGeneratedColumn,
  ManyToOne,
  JoinColumn,
} from 'typeorm';
import { Token } from './Token.entity';

@Entity()
export class Transfer {
  // ... other fields

  @ManyToOne(() => Token)
  @JoinColumn({ name: 'contractAddress' })
  token: Token;

  // ... other fields
}
```

## Automatic API Generation

The Open Ethereum Indexer can automatically generate REST APIs for your entities:

```typescript
// main.ts
import { NestFactory } from '@nestjs/core';
import { IndexerModule, setupSwagger } from '@open-ethereum/indexer';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // Setup Swagger documentation
  setupSwagger(app);

  await app.listen(3000);
  console.log('Application running on port 3000');
}
bootstrap();
```

This creates endpoints like:

- `GET /api/transfers` - List all transfers
- `GET /api/transfers/:id` - Get a specific transfer
- `GET /api/tokens` - List all tokens
- `GET /api/tokens/:address` - Get a specific token

## Entity Migrations

When you change your entity structure, you'll need to create migrations to update the database schema:

```bash
# Generate a migration
npx typeorm migration:generate -n UpdateTransferEntity

# Run migrations
npx typeorm migration:run
```

## GraphQL Integration

The Open Ethereum Indexer also supports GraphQL for querying your entities. See the [GraphQL](./graphql) section for more details.

## TODO: Converting Solidity Events to TypeORM Entities

TODO
