# Subscriptions

Open Ethereum Indexer provides a flexible subscription system that integrates with NestJS dependency injection. This page explains the different ways to register event and block handlers, and how to use NestJS providers with them.

## Static vs. Dynamic Handlers

The indexer supports two types of handlers:

1. **Static Handlers**: Registered directly using global functions, outside of any class
2. **Dynamic Handlers**: Registered within NestJS services using dependency injection

### Static Handlers

Static handlers are registered using the global `onEvent` and `onBlock` functions:

```typescript
// In subscriptions.ts or any file that's imported at application startup
import { onEvent, onBlock } from '@open-ethereum/indexer';

// Static event handler
onEvent('Contract:Event', {
  onIndex: async (payload) => {
    console.log('Event processed:', payload);
  },
});

// Static block handler
onBlock({
  onIndex: async (payload) => {
    console.log('Block processed:', payload);
  },
});
```

These handlers are registered before the application starts and don't have access to NestJS dependency injection.

### Dynamic Handlers

Dynamic handlers are registered within NestJS services and have full access to dependency injection:

```typescript
import { Injectable, OnModuleInit } from '@nestjs/common';
import { EventManagerService } from '@open-ethereum/indexer';

@Injectable()
export class MyEventService implements OnModuleInit {
  constructor(private readonly eventManager: EventManagerService) {}

  onModuleInit() {
    // Register event handler within the service
    this.eventManager.onEvent('Contract:Event', {
      onIndex: async (payload) => {
        // Access service methods and properties here
        await this.processEvent(payload);
      },
    });

    // Register block handler within the service
    this.eventManager.onBlock({
      onIndex: async (payload) => {
        await this.processBlock(payload);
      },
    });
  }

  private async processEvent(payload: any) {
    // Use other services and database connections
    console.log('Processing event in service');
  }

  private async processBlock(payload: any) {
    // Use other services and database connections
    console.log('Processing block in service');
  }
}
```

## Using NestJS Providers

NestJS providers give you access to dependency injection, allowing your handlers to use other services.

### Example: Using Services in Handlers

Here's a complete example of a service that processes events and uses dependency injection:

```typescript
// event.service.ts
import { Injectable, OnModuleInit, Logger } from '@nestjs/common';
import { EventManagerService } from '@open-ethereum/indexer';
import { DatabaseService } from './database.service';

@Injectable()
export class EventService implements OnModuleInit {
  private readonly logger = new Logger(EventService.name);

  constructor(
    private readonly eventManager: EventManagerService,
    private readonly databaseService: DatabaseService,
  ) {}

  onModuleInit() {
    this.logger.log('Registering event handlers');

    // Register event handler
    this.eventManager.onEvent('ERC20:Transfer', {
      onIndex: async (payload) => {
        const { from, to, value } = payload.parsedEvent.args;

        // Use injected service
        await this.databaseService.saveTransfer({
          from,
          to,
          value: value.toString(),
          blockNumber: payload.block.number,
        });
      },
    });
  }
}
```

Then, make sure to include your service in a module:

```typescript
// app.module.ts
import { Module } from '@nestjs/common';
import { IndexerModule } from '@open-ethereum/indexer';
import { EventService } from './event.service';
import { DatabaseService } from './database.service';

@Module({
  imports: [IndexerModule.forRoot(indexerConfig)],
  providers: [EventService, DatabaseService],
})
export class AppModule {}
```

## Accessing NestJS Services from Static Handlers

Sometimes you might need to access NestJS services from static handlers. One approach is to use a provider singleton pattern:

```typescript
// service-provider.ts
export class ServiceProvider {
  private static instance: ServiceProvider;
  private services: Map<string, any> = new Map();

  private constructor() {}

  static getInstance(): ServiceProvider {
    if (!ServiceProvider.instance) {
      ServiceProvider.instance = new ServiceProvider();
    }
    return ServiceProvider.instance;
  }

  setService(name: string, service: any): void {
    this.services.set(name, service);
  }

  getService<T>(name: string): T | null {
    return (this.services.get(name) as T) || null;
  }
}
```

```typescript
// telegram.service.ts
import { Injectable, OnModuleInit } from '@nestjs/common';
import { ServiceProvider } from './service-provider';

@Injectable()
export class TelegramService implements OnModuleInit {
  onModuleInit() {
    // Register this service in the provider
    ServiceProvider.getInstance().setService('telegram', this);
  }

  sendMessage(message: string): Promise<void> {
    console.log('Sending message:', message);
    return Promise.resolve();
  }
}
```

```typescript
// subscriptions.ts
import { onBlock } from '@open-ethereum/indexer';
import { ServiceProvider } from './service-provider';

onBlock({
  onIndex: async (payload) => {
    const { number } = payload;

    if (number % 1000 === 0) {
      // Get the service from the provider
      const telegramService =
        ServiceProvider.getInstance().getService<TelegramService>('telegram');

      if (telegramService) {
        await telegramService.sendMessage(`Block ${number} processed`);
      }
    }
  },
});
```

## Differences Between Static and Dynamic Handlers

| Feature              | Static Handlers                  | Dynamic Handlers                  |
| -------------------- | -------------------------------- | --------------------------------- |
| Registration         | At module load time              | During NestJS lifecycle           |
| Dependency Injection | No direct access                 | Full access                       |
| Initialization       | Before NestJS starts             | After NestJS services are ready   |
| Use Case             | Simple handlers, no dependencies | Complex handlers needing services |
| Persistence          | Throughout application lifecycle | Tied to service lifecycle         |

## Best Practices

1. **Use dynamic handlers** when you need access to NestJS services and dependency injection
2. **Use static handlers** for simple processing that doesn't require other services
3. **Keep handlers focused** on their specific task, following the Single Responsibility Principle
4. **Consider service provider pattern** when you need to access services from static handlers
