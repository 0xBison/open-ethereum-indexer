# Subscriptions

Open Ethereum Indexer provides multiple ways to handle blockchain events and blocks. This page explains the different approaches available.

## Class-based Subscribers (Recommended)

The recommended way to create subscribers is by extending the abstract subscriber classes. This approach provides better TypeScript support and cleaner code organization.

### Event Subscribers

To create an event subscriber, extend the `AbstractEventSubscriber` class:

```typescript
import { Injectable } from '@nestjs/common';
import {
  AbstractEventSubscriber,
  LogEvent,
  LogContext,
} from '@open-ethereum/indexer';
import { MyCustomService } from './my-custom.service';

@Injectable()
export class TransferSubscriber extends AbstractEventSubscriber {
  // Required: Specify the event pattern to listen for
  readonly eventPattern = 'ERC20:Transfer';

  constructor(
    private myCustomService: MyCustomService, // Inject your services
  ) {
    super();
  }

  // Optional: Handle indexing events
  async onIndex(payload: LogEvent, context: LogContext): Promise<void> {
    const { parsedEvent } = payload;
    const { from, to, value } = parsedEvent.args;

    await this.myCustomService.processTransfer(from, to, value);
  }

  // Optional: Handle de-indexing events (e.g., on chain reorganizations)
  async onDeindex(payload: LogEvent, context: LogContext): Promise<void> {
    // Handle event removal
  }
}
```

### Block Subscribers

For block-level events, extend the `AbstractBlockSubscriber` class:

```typescript
import { Injectable } from '@nestjs/common';
import {
  AbstractBlockSubscriber,
  BlockEvent,
  LogContext,
} from '@open-ethereum/indexer';
import { BlockAnalyticsService } from './block-analytics.service';

@Injectable()
export class BlockMetricsSubscriber extends AbstractBlockSubscriber {
  constructor(
    private blockAnalytics: BlockAnalyticsService, // Inject your services
  ) {
    super();
  }

  // Optional: Handle new blocks
  async onIndex(payload: BlockEvent, context: LogContext): Promise<void> {
    const { number, timestamp, transactions } = payload;
    await this.blockAnalytics.recordBlockMetrics(
      number,
      timestamp,
      transactions.length,
    );
  }

  // Optional: Handle block removals
  async onDeindex(payload: BlockEvent, context: LogContext): Promise<void> {
    // Handle block removal
  }
}
```

### Registering Subscribers

Register your subscribers in your NestJS module:

```typescript
import { Module } from '@nestjs/common';
import { IndexerModule } from '@open-ethereum/indexer';
import { TransferSubscriber } from './transfer.subscriber';
import { BlockMetricsSubscriber } from './block-metrics.subscriber';
import { MyCustomService } from './my-custom.service';
import { BlockAnalyticsService } from './block-analytics.service';

@Module({
  imports: [IndexerModule.forRoot(indexerConfig)],
  providers: [
    TransferSubscriber,
    BlockMetricsSubscriber,
    MyCustomService,
    BlockAnalyticsService,
  ],
})
export class AppModule {}
```

### Key Benefits of Class-based Subscribers

1. **Type Safety**: Full TypeScript support for event payloads and context
2. **Dependency Injection**: Clean integration with NestJS DI system
3. **Code Organization**: Better separation of concerns
4. **Optional Methods**: Implement only the methods you need
5. **Automatic Registration**: No need to manually register in `onModuleInit`

## Service-based Subscribers (Legacy)

[Previous documentation about EventManagerService-based subscribers remains unchanged...]

## Static Handlers

[Previous documentation about static handlers remains unchanged...]

## Choosing an Approach

Here's a comparison of the different subscription approaches:

| Feature              | Class-based Subscribers | Service-based Subscribers | Static Handlers             |
| -------------------- | ----------------------- | ------------------------- | --------------------------- |
| TypeScript Support   | Full                    | Partial                   | Limited                     |
| Dependency Injection | Native                  | Native                    | Requires Service Provider   |
| Code Organization    | Best                    | Good                      | Basic                       |
| Setup Complexity     | Low                     | Medium                    | Low                         |
| Use Case             | Most scenarios          | Legacy code               | Simple, standalone handlers |
| Recommended For      | New development         | Existing implementations  | Basic processing            |

## Best Practices

1. **Use Class-based Subscribers** for new development
2. **Implement Only Needed Methods** in subscribers (onIndex/onDeindex are optional)
3. **Keep Subscribers Focused** on specific event types or functionality
4. **Leverage Dependency Injection** for clean service integration
5. **Use Meaningful Names** for subscriber classes that reflect their purpose
